

《现代操作系统》笔记

1. 进程与线程
   1. 进程与程序的区别
      1. 创建进程的情况：系统/批处理init；用户主动创建；其他进程调用创建
      2. 退出进程的情况：主动退出；出错(自愿)；出错(非自愿)；被其他进程kill
      3. 进程的3种状态：阻塞(等输入)；就绪(有输入 等待调度)；运行
      4. 进程表&进程表项(程序管理, 存储管理, 文件管理)：中断发生时，程序计数器、程序状态字、一或多个寄存器压入堆栈(均有硬件处理)，剩下的由软件(中断服务例程)处理

   2. 线程（线程与进程的区别      进程包含：一个地址空间, 一个控制线程）
      1. 多线程是可以共享同一个地址空间和所有可用数据的并行实体；如果多个线程有一些是要大量计算/大量I/O那么使用多线程可允许起活动重叠以加速
      2. 多线程应用的例子：
         1. 多个用同个地址空间, 各自有不同职责：字处理软件(用户交互线程, 格式化线程, 磁盘备份线程)，当然可以用“中断”的方法，但太过复杂
         2. 一个分派, 其他工作：分派线程和工作线程(多个)
      3. 架设服务器的三种方式
         1. 多线程（并发；阻塞系统调用）
         2. 单线程（不并发；阻塞）
         3. 有限状态机（并发；不阻塞；中断）

   3. 阻塞与非阻塞(侧重于调用) (“同步”与“异步”侧重于通信)
     阻塞(blocking)：调用方（主线程）发起调用之后挂起直到被调用方法返回。
     非阻塞(non-blocking)：调用方发起调用之后，不会挂起，而是马上继续执行调用块之后的逻辑。

   4. 线程：一个程序计数器(记录下一条指令)、一个寄存器(存变量)、一个堆栈(执行历史，已调用未返回的)
     线程实际上是CPU上被调度执行的实体

   5. IEEE 1003.1c线程标准——Pthread
     Pthread_create, Pthread_exit, Pthread_join(等待一个线程退出), Pthread_yield(线程主动放弃), Pthread_attr_init, 			Pthread_attr_destroy(线程的属性结构)

   6. 用户级线程和内核级线程
      1. 用户级线程
         1. 优点：线程创建管理切换快；允许每个进程有自己的调度算法
         2. 缺点：内核若为单线程，任一线程执行阻塞的系统调用会阻塞整个进程(可以用select)；页面故障时
      2. 内核级线程
         1. 优点：不需要任何新的非阻塞的系统调用；页面故障时检查是否有可运行线程很方便
         2. 缺点：系统调用代价大开销大
      3. 混合实现
      4. 调度程序激活机制

         1. 目的：模拟内核线程功能，但为险承保提供在用户空间中才能实现的性能和灵活性
         2. 做法：内核给每个进程安排一定数量的虚拟处理器，用户空间的运行时系统将线程分配到处理器上。当内核发现某个线程被阻塞后，内核通知进程的运行时系统，并把参数压入堆栈。运行时系统则把当前线程标记为阻塞，并从就绪表取出另一个线程，设置其寄存器，启动之。之后如果内核知道了原线程又好了则通知运行时系统，系统根据自己的判断选择立即启动或放入就绪表
      5. 弹出式线程：息到来时，快速创建一个线程来处理

2. 进程间通信
   1. 三个问题：一个进程如何传递信息给另一个？；如何使多进程不会相互影响？；竞争条件如何处理(顺序关系)？
   2. 临界区（避免互斥条件的关键）
      1. 不能有多个进程同时在临界区；
      2. 临界区外的进程不能阻塞其他进程（指等待临界资源的其他进程或临界区内的进程）；
      3. 不能无限等待临界资源；
      4. 不能对cpu的数量、速度有假设
   3. 有什么办法来实现互斥？(即某一时间最多只有一个进程在临界区)
      1. 屏蔽中断：每个进程进入临界区后屏蔽外来的中断请求，离开时打开中断。
         1. 缺点：会屏蔽时钟中断，故cpu不会切换进程；屏蔽中断只对执行disable指令的cpu有效，其他cpu一样可以访问临界区
      2. 锁变量（但存在与假脱机目录一样的问题）：检测锁(0表示临界区可用，1表示不可用)，如果A检测后切换到另一个B，B改变了变量并进入，之后A又进入
      3. 严格轮换：用while(turn!=0)和(turn!=1)，我好了就换你，但如果A进入又出来，但B又还在忙非临界区，A只能等
      4. Perterson解法：精髓是进入临界区前要检测while(interested==process&&interested[other]==TRUE) 后来的由于已有人进入 所以interested[other]使其等待
      5. TSL(test and set lock)：目的是为了锁住内存总线，可以在多cpu处理时不让其他cpu访问（区别于屏蔽中断只对单cpu有用）
      6. 睡眠与唤醒：up和down，down操作检查信号量(0或正数)，如果发现为0则进程睡眠，但此时down操作未结束；大于0则-1；检查数值、修改变量值、睡眠都是原子操作不可分割。（可通过屏蔽中断(单cpu)/TSL或XCHG(多cpu)来实现）
      7. 消费者-生产者问题中用到的3个信号量（实际2个也可以，但为了0的用法统一，full(已占)给消费者用，empty(空位)给生产者用(别反了，full=0表示都占用0个，即空；empty=0表示空位0个，即满；可以将**=0理解为非**)，mutex(互斥)是二元信号量，保证临界区(这里指的是整个缓冲区)只有1个进程，比如生产者要放入缓冲区、消费者拿走）    （在这里信号量实现了互斥以及同步(保证顺序)的作用）
      8. mutex_lock和enter_region区别：mutex_lock会忙等待；enter_region在有人在临界区时会调用thread_yield将cpu放弃给别的线程
      9. 共享turn变量：一种是共享数据结构；一种是进程与其他进程共享部分地址空间
      10. Pthread中关于互斥量：前缀均为pthread_mutex_；后缀有init(创建互斥量)；trylock(测试或失败)；lock(锁或阻塞)；unlock(释放锁)；destroy(撤销互斥量)
      11. Pthread条件变量(用于外部触发)：前缀pthread_cond_；后最有init；wait(阻塞并等待)；signal(向另一个进程发信号)；broadcast(向多个进程发信号)；destroy(撤销)。 条件变量也可以实现消费者-生产者问题（进入临界区后）
      12. 管程(monitor)：编译器安排互斥而非程序员 wait会阻塞自己 需要接着signal别人 signal执行后退出 或者将自己挂起 切换到别人
   4. 消息传递 send和receive（系统调用 而不是语言成分，用于分布式 多个cpu通过互联网相连。信号量太低级，而管程受语言种类限制）：空消息，往里面填。有点像传输版的共享内存
      1. 信箱：send、receive调用的地址参数是信箱的地址而不是进程的地址 
      2. 屏障：挡住 全部人到齐了再继续

3. 调度
   1. 调度算法要考虑要的指标：反应时间, 平均等待时间, 是否公平, 实时
   2. FCFS(first come first served)
   3. 短作业优先(SJR)（SJR实际也是一种优先级调度）：平均等待时间肯定是最优的 但不能保证公平
   4. 非抢占式(拿到cpu就执行到完)和抢占式(来一个就打断 判断该由谁执行)
   5. 三级调度：接纳调度（是否进system）；内存调度（去内存还是disk）；cpu调度（最终执行调度）
   6. 轮转调度(RR)：切成时间片(“时间片”概念相对于“上下文”) 执行完一个时间片的process去最后面 （平均等待时间不一定好 但响应好）
   7. 优先级调度的缺点：低优先级的process可能永远拿不到cpu 解决方案：Aging（年龄）随着等待时间增加优先级增加
   8. 多级队列调度：多个队列 每个队列有自己的调度算法
   9. 彩票调度：公平 随机
   10. 实时调度：硬实时(导航, 高铁自动驾驶)和软实时(早一点晚一点会有影响 但不是致命性错误)
   11. 线程调度：用户级线程调度（内核调用进程 运行时系统run-time system调用线程）和内核级线程调用（内核直接调用线程）

4. 存储管理
   1. 页表
      1. 普通页表
      2. 两级页表
      3. TLB(translation lookaside buffer)联想内存
      4. 倒置页表（减少了每一页表的内存，但增加了查找页时间，可用hashing）
   2. 置换方法
      1. NRU（Not Recently Used）最近未使用 ：R位(read)和M位(modified) 4类(00,01,10,11) 定期(20ms)清零，故障时扔掉最小类
      2. FIFO：易实现，但是可能常用的被扔出去(加表尾，扔表头)
      3. Second Chance第二次机会算法：R=0扔掉；R=1时把R置0，放在表尾(当成新加入)
      4. Clock时钟算法：
      5. LRU（Least Recently Used）最近最少使用：扔掉未使用中时间最长的
         1. 效果很好，但代价很昂贵，需要维护一个页面链表，且每次访问内存都要更新链表（最近用的在表头，没怎么用的在表尾）
         2. 硬件实现：每条使用后+1，定期全部清零；维护一个n^2的矩阵，访问i，把i_row置1，i_col置0，最后看sum_row，多的常用，少的少用，扔掉少的 //行置1意思是刚用的自己满上，列置0意思是把别人都-1，这样刚用过就很多，而一直不被用就会一直被减，直至被遗忘

         3. 软件模拟：
            1. NFU（Not Frequently Used）：用过+1，缺点是NFU不过忘记任何事，以前常用的会一直不被扔
            2. 老化算法：计数器右移，最左位=current_R
      6. 工作集算法
      7. WSClock（工作集时钟算法）：R=1时，跳过不扔但置0；R=0时，查看生存时间（实际已使用cpu时间），如果生存时间>τ，则置换；生存时间<τ，则暂时保留，如果扫描完整个页表其他都是R=1，有一个或多个该情况，则置换生存时间最长的。
   3. 段表（分页方式的优点是页长固定，便于构造页表、易于管理，且不存在外碎片。但分页方式的缺点是页长与程序的逻辑大小不相关，故产生了分段方式）
      1. 缺点：容易在段间留下许多碎片；主存空间分配比较麻烦
   4. 段页式存储
      1. 一个逻辑地址用三个参数表示：段号S+页号P+页内地址d
      2. 优点：提供了大量的虚拟存储空间；能有效地利用主存
      3. 缺点：增加了硬件成本、系统复杂性、管理开消；存在着系统发生抖动的危险；存在着内碎片；各种表格要占用主存空间